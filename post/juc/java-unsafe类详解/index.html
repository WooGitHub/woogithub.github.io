<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java Unsafe类详解 - Woo_home</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Woo_home" /><meta name="description" content="什么是 Unsafe？ Unsafe 是位于 sun.misc 包下的一个类，主要提供了一些用于执行低级别、不安全操作的方法，如直接访问系统的内存资源、自主管理内存资源等，这" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.56.3 with theme even" />


<link rel="canonical" href="https://woogithub.github.io/post/juc/java-unsafe%E7%B1%BB%E8%AF%A6%E8%A7%A3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java Unsafe类详解" />
<meta property="og:description" content="什么是 Unsafe？ Unsafe 是位于 sun.misc 包下的一个类，主要提供了一些用于执行低级别、不安全操作的方法，如直接访问系统的内存资源、自主管理内存资源等，这" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://woogithub.github.io/post/juc/java-unsafe%E7%B1%BB%E8%AF%A6%E8%A7%A3/" />
<meta property="article:published_time" content="2019-12-23T00:14:19+08:00" />
<meta property="article:modified_time" content="2019-12-23T00:14:19+08:00" />
<meta itemprop="name" content="Java Unsafe类详解">
<meta itemprop="description" content="什么是 Unsafe？ Unsafe 是位于 sun.misc 包下的一个类，主要提供了一些用于执行低级别、不安全操作的方法，如直接访问系统的内存资源、自主管理内存资源等，这">


<meta itemprop="datePublished" content="2019-12-23T00:14:19&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-23T00:14:19&#43;08:00" />
<meta itemprop="wordCount" content="6920">



<meta itemprop="keywords" content="JUC," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java Unsafe类详解"/>
<meta name="twitter:description" content="什么是 Unsafe？ Unsafe 是位于 sun.misc 包下的一个类，主要提供了一些用于执行低级别、不安全操作的方法，如直接访问系统的内存资源、自主管理内存资源等，这"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Woo_home</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="https://blog.csdn.net/Woo_home">
        <li class="mobile-menu-item">CSDN</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Woo_home</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://blog.csdn.net/Woo_home">CSDN</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java Unsafe类详解</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-12-23 </span>
        
          <span class="more-meta"> 6920 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> 阅读数 <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#什么是-unsafe">什么是 Unsafe？</a></li>
<li><a href="#unsafe的基本介绍">Unsafe的基本介绍</a></li>
<li><a href="#功能介绍">功能介绍</a>
<ul>
<li><a href="#内存操作">内存操作</a>
<ul>
<li><a href="#使用堆外内存的原因">使用堆外内存的原因</a></li>
<li><a href="#典型应用">典型应用</a></li>
</ul></li>
<li><a href="#cas相关">CAS相关</a>
<ul>
<li><a href="#典型应用-1">典型应用</a></li>
</ul></li>
<li><a href="#线程调度">线程调度</a>
<ul>
<li><a href="#典型应用-2">典型应用</a></li>
</ul></li>
<li><a href="#class相关">Class相关</a>
<ul>
<li><a href="#典型应用-3">典型应用</a></li>
</ul></li>
<li><a href="#对象操作">对象操作</a>
<ul>
<li><a href="#典型应用-4">典型应用</a></li>
</ul></li>
<li><a href="#数组相关">数组相关</a>
<ul>
<li><a href="#典型应用-5">典型应用</a></li>
</ul></li>
<li><a href="#内存屏障">内存屏障</a>
<ul>
<li><a href="#典型应用-6">典型应用</a></li>
</ul></li>
<li><a href="#系统相关">系统相关</a>
<ul>
<li><a href="#典型应用-7">典型应用</a></li>
</ul></li>
</ul></li>
<li><a href="#结语">结语</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h2 id="什么是-unsafe">什么是 Unsafe？</h2>

<p>Unsafe 是位于 sun.misc 包下的一个类，主要提供了一些用于执行低级别、不安全操作的方法，如直接访问系统的内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但是由于 Unsafe 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再 “安全”，因此在对 Unsafe 类的使用一定要慎重</p>

<h2 id="unsafe的基本介绍">Unsafe的基本介绍</h2>

<p>以下是 Unsafe 的源码</p>

<p>Unsafe 类是以单例实现，提供静态方法 getUnsafe 获取 Unsafe 实例，当且仅当调用 getUnsafe 方法的类为引导类加载器所加载时才合法，否则会抛出 SecurityException</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">final</span> <span class="kd">class</span> <span class="nf">Unsafe</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="nf">static</span> <span class="kd">final</span> <span class="nf">Unsafe</span> <span class="n">theUnsafe</span><span class="p">;</span>

    <span class="kd">private</span> <span class="nf">Unsafe</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="nd">@CallerSensitive</span>
    <span class="kd">public</span> <span class="nf">static</span> <span class="n">Unsafe</span> <span class="nf">getUnsafe</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Class</span> <span class="nf">var0</span> <span class="o">=</span> <span class="n">Reflection</span><span class="p">.</span><span class="na">getCallerClass</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VM</span><span class="p">.</span><span class="na">isSystemDomainLoader</span><span class="p">(</span><span class="n">var0</span><span class="p">.</span><span class="na">getClassLoader</span><span class="p">()))</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">SecurityException</span><span class="p">(</span><span class="s">&#34;Unsafe&#34;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">theUnsafe</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>那如若想使用这个类，该如何获取其实例？有如下两个可行方案：</p>

<ul>
<li><p>其一，从<code>getUnsafe</code>方法的使用限制条件出发，通过Java命令行命令<code>-Xbootclasspath/a</code>把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取Unsafe实例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span> <span class="o">-</span><span class="n">Xbootclasspath</span><span class="o">/</span><span class="n">a</span><span class="o">:</span> <span class="n">$</span><span class="p">{</span><span class="n">path</span><span class="p">}</span>   <span class="o">//</span> <span class="n">其中path为调用Unsafe相关方法的类所在jar包路径</span> </code></pre></td></tr></table>
</div>
</div></li>

<li><p>通过反射获取单例对象 theUnsafe</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="nf">static</span> <span class="n">Unsafe</span> <span class="nf">reflectGetUnsafe</span><span class="p">()</span> <span class="p">{</span>  
<span class="k">try</span> <span class="p">{</span>
    <span class="n">Field</span> <span class="nf">field</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getDeclaredField</span><span class="p">(</span><span class="s">&#34;theUnsafe&#34;</span><span class="p">);</span>
    <span class="n">field</span><span class="p">.</span><span class="na">setAccessible</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Unsafe</span><span class="p">)</span> <span class="n">field</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">.</span><span class="na">error</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">getMessage</span><span class="p">(),</span> <span class="n">e</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="功能介绍">功能介绍</h2>

<p><img src="https://p1.meituan.net/travelcube/f182555953e29cec76497ebaec526fd1297846.png" alt="img" /></p>

<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍</p>

<h3 id="内存操作">内存操作</h3>

<p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//分配内存, 相当于C++的malloc函数
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">long</span> <span class="nf">allocateMemory</span><span class="p">(</span><span class="kt">long</span> <span class="nf">bytes</span><span class="p">);</span>

<span class="c1">//扩充内存
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">long</span> <span class="nf">reallocateMemory</span><span class="p">(</span><span class="kt">long</span> <span class="nf">address</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">bytes</span><span class="p">);</span>

<span class="c1">//释放内存
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">freeMemory</span><span class="p">(</span><span class="kt">long</span> <span class="nf">address</span><span class="p">);</span>

<span class="c1">//在给定的内存块中设置值
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">setMemory</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">bytes</span><span class="p">,</span> <span class="kt">byte</span> <span class="nf">value</span><span class="p">);</span>

<span class="c1">//内存拷贝
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">copyMemory</span><span class="p">(</span><span class="n">Object</span> <span class="nf">srcBase</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">srcOffset</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">destBase</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">destOffset</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">bytes</span><span class="p">);</span>

<span class="c1">//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">);</span>

<span class="c1">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">putObject</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">x</span><span class="p">);</span>

<span class="c1">//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">byte</span> <span class="nf">getByte</span><span class="p">(</span><span class="kt">long</span> <span class="nf">address</span><span class="p">);</span>

<span class="c1">//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">putByte</span><span class="p">(</span><span class="kt">long</span> <span class="nf">address</span><span class="p">,</span> <span class="kt">byte</span> <span class="nf">x</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>通常，我们在 Java 中创建的对象都处于堆内内存（heap）中，堆内内存是由 JVM 所管控的 Java 进程内存，并且它们遵循 JVM 的内存管理机制，JVM 会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于 JVM 管控之外的内存区域，Java 中对堆外内存的操作，依赖于 Unsafe 提供的操作堆外内存的 native 方法</p>

<h4 id="使用堆外内存的原因">使用堆外内存的原因</h4>

<ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响</li>
<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存</li>
</ul>

<h4 id="典型应用">典型应用</h4>

<p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现</p>

<p>下面的源码为 DirectByteBuffer 构造函数，创建 DirectByteBuffer 的时候，通过 Unsafe.allocateMemory 分配内存、Unsafe.setMemory 进行内存初始化，而后构建 Cleaner 对象用于跟踪 DirectByteBuffer 对象的垃圾回收，以实现当 DirectByteBuffer 被垃圾回收时，分配的堆外内存一起被释放</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DirectByteBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="nf">cap</span><span class="p">)</span> <span class="p">{</span>                   <span class="c1">// package-private
</span><span class="c1"></span>    <span class="kd">super</span><span class="p">(</span><span class="o">-</span><span class="n">1</span><span class="p">,</span> <span class="n">0</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
    <span class="kt">boolean</span> <span class="nf">pa</span> <span class="o">=</span> <span class="n">VM</span><span class="p">.</span><span class="na">isDirectMemoryPageAligned</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">ps</span> <span class="o">=</span> <span class="n">Bits</span><span class="p">.</span><span class="na">pageSize</span><span class="p">();</span>
    <span class="kt">long</span> <span class="nf">size</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">cap</span> <span class="o">+</span> <span class="p">(</span><span class="n">pa</span> <span class="o">?</span> <span class="n">ps</span> <span class="o">:</span> <span class="n">0</span><span class="p">));</span>
    <span class="n">Bits</span><span class="p">.</span><span class="na">reserveMemory</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="kt">long</span> <span class="nf">base</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">unsafe</span><span class="p">.</span><span class="na">allocateMemory</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">OutOfMemoryError</span> <span class="nf">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Bits</span><span class="p">.</span><span class="na">unreserveMemory</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
        <span class="k">throw</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">unsafe</span><span class="p">.</span><span class="na">setMemory</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span> <span class="n">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">base</span> <span class="o">%</span> <span class="n">ps</span> <span class="o">!=</span> <span class="n">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Round up to page boundary
</span><span class="c1"></span>        <span class="n">address</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">ps</span> <span class="o">-</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ps</span> <span class="o">-</span> <span class="n">1</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cleaner</span> <span class="o">=</span> <span class="n">Cleaner</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="n">Deallocator</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cap</span><span class="p">));</span>
    <span class="n">att</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？</p>

<p>Cleaner 继承自 Java 四大引用类型之一的虚引用 PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常 PhantomReference 与引用队列ReferenceQueue 结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被 Cleaner 引用的对象将被回收时，JVM 垃圾收集器会将此对象的引用放入到对象引用中的 pending 链表中，等待 Reference-Handler 进行相关处理。其中，Reference-Handler 为一个拥有最高优先级的守护线程，会循环不断的处理pending 链表中的对象引用，执行 Cleaner 的 clean 方法进行相关清理工作</p>

<p><img src="https://p0.meituan.net/travelcube/9efac865a875c32cf570489332be5d0f131298.png" alt="img" /></p>

<p>所以当 DirectByteBuffer 仅被 Cleaner 引用（即为虚引用）时，其可以在任意GC时段被回收。当 DirectByteBuffer 实例对象被回收时，在 Reference-Handler 线程操作中，会调用 Cleaner 的 clean 方法根据创建 Cleaner 时传入的 Deallocator来进行堆外内存的释放</p>

<p><img src="https://img-blog.csdnimg.cn/20191224155936595.png" alt="" /></p>

<p><img src="https://img-blog.csdnimg.cn/20191224160046815.png" alt="" /></p>

<h3 id="cas相关">CAS相关</h3>

<p>如下源代码释义所示，这部分主要为CAS相关操作的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  *  CAS
</span><span class="cm">  * @param o         包含要修改field的对象
</span><span class="cm">  * @param offset    对象中某field的偏移量
</span><span class="cm">  * @param expected  期望值
</span><span class="cm">  * @param update    更新值
</span><span class="cm">  * @return          true | false
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">final</span> <span class="kd">native</span> <span class="nf">boolean</span> <span class="n">compareAndSwapObject</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span>  <span class="n">Object</span> <span class="nf">expected</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">update</span><span class="p">);</span>

<span class="kd">public</span> <span class="nf">final</span> <span class="kd">native</span> <span class="nf">boolean</span> <span class="n">compareAndSwapInt</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">expected</span><span class="p">,</span><span class="kt">int</span> <span class="nf">update</span><span class="p">);</span>
  
<span class="kd">public</span> <span class="nf">final</span> <span class="kd">native</span> <span class="nf">boolean</span> <span class="n">compareAndSwapLong</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">expected</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">update</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>什么是 CAS ? 即比较并替换，实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg</p>

<h4 id="典型应用-1">典型应用</h4>

<p>CAS 在 java.util.concurrent.atomic 相关类、AQS、CurrentHashMap 等实现上有非常广泛的应用。如下图所示，AtomicInteger 的实现中，静态字段 valueOffset 即为字段value的内存偏移地址，valueOffset 的值在 AtomicInteger 初始化时，在静态代码块中通过 Unsafe 的 objectFieldOffset 方法获取。在 AtomicInteger 中提供的线程安全方法中，通过字段 valueOffset 的值可以定位到 AtomicInteger 对象中value的内存地址，从而可以根据 CAS 实现对 value 字段的原子操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 通过 Unsafe 计算出 value 变量在对象中的偏移
</span><span class="c1"></span><span class="kd">static</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 通过 Unsafe 的objectFieldOffset 方法中获取
</span><span class="c1"></span>        <span class="c1">// 通过字段 valueOffset 的值可以定位到 AtomicInteger 对象中 value 的内存地址
</span><span class="c1"></span>        <span class="c1">// 从而可以根据 CAS 实现对 value 字段的原子操作
</span><span class="c1"></span>        <span class="n">valueOffset</span> <span class="o">=</span> <span class="n">unsafe</span><span class="p">.</span><span class="na">objectFieldOffset</span>
            <span class="p">(</span><span class="n">AtomicInteger</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getDeclaredField</span><span class="p">(</span><span class="s">&#34;value&#34;</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">ex</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>下图为某个 AtomicInteger 对象自增操作前后的内存示意图，对象的基地址 baseAddress=“0x110000”，通过 baseAddress + valueOffset 得到 value 的内存地址 valueAddress=“0x11000c”；然后通过 CAS 进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止</p>

<p><img src="https://p0.meituan.net/travelcube/6e8b1fe5d5993d17a4c5b69bb72ac51d89826.png" alt="img" /></p>

<h3 id="线程调度">线程调度</h3>

<p>这部分，包括线程挂起、恢复、锁机制等方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//取消阻塞线程
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">unpark</span><span class="p">(</span><span class="n">Object</span> <span class="nf">thread</span><span class="p">);</span>

<span class="c1">//阻塞线程
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">park</span><span class="p">(</span><span class="kt">boolean</span> <span class="nf">isAbsolute</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">time</span><span class="p">);</span>

<span class="c1">//获得对象锁（可重入锁）注解代表已经弃用了
</span><span class="c1"></span><span class="nd">@Deprecated</span>
<span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">monitorEnter</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">);</span>

<span class="c1">//释放对象锁，注解代表已经弃用了
</span><span class="c1"></span><span class="nd">@Deprecated</span>
<span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">monitorExit</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">);</span>

<span class="c1">//尝试获取对象锁，注解代表已经弃用了
</span><span class="c1"></span><span class="nd">@Deprecated</span>
<span class="kd">public</span> <span class="nf">native</span> <span class="kt">boolean</span> <span class="nf">tryMonitorEnter</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>如上源码说明中，方法 park、unpark 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 park 方法实现的，调用park 方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark 可以终止一个挂起的线程，使其恢复正常。</p>

<h4 id="典型应用-2">典型应用</h4>

<p>Java 锁和同步器框架的核心类 AbstractQueuedSynchronizer，就是通过调用 <font color="brown">LockSupport.park() 和 LockSupport.unpark()</font> 实现线程的阻塞和唤醒的，而 LockSupport 的 park、unpark 方法实际是调用 Unsafe 的 park、unpark 方式来实现</p>

<h3 id="class相关">Class相关</h3>

<p>此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">long</span> <span class="nf">staticFieldOffset</span><span class="p">(</span><span class="n">Field</span> <span class="nf">f</span><span class="p">);</span>

<span class="c1">//获取一个静态类中给定字段的对象指针
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Object</span> <span class="nf">staticFieldBase</span><span class="p">(</span><span class="n">Field</span> <span class="nf">f</span><span class="p">);</span>

<span class="c1">//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">boolean</span> <span class="nf">shouldBeInitialized</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="p">);</span>

<span class="c1">//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">ensureClassInitialized</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="p">);</span>

<span class="c1">//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">defineClass</span><span class="p">(</span><span class="n">String</span> <span class="nf">name</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="nf">b</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">off</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">len</span><span class="p">,</span> <span class="n">ClassLoader</span> <span class="nf">loader</span><span class="p">,</span> <span class="n">ProtectionDomain</span> <span class="nf">protectionDomain</span><span class="p">);</span>

<span class="c1">//定义一个匿名类
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">defineAnonymousClass</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">hostClass</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="nf">data</span><span class="p">,</span> <span class="n">Object</span><span class="p">[]</span> <span class="nf">cpPatches</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="典型应用-3">典型应用</h4>

<p>从Java 8开始，JDK 使用 invokedynamic 及 VM Anonymous Class 结合来实现 Java 语言层面上的 Lambda 表达式。</p>

<ul>
<li><strong>invokedynamic</strong>： invokedynamic 是 Java 7 为了实现在 JVM 上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic 指令的分派逻辑是由用户设定的引导方法决定。</li>
<li><strong>VM Anonymous Class</strong>：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过 Unsafe.defineAnonymousClass 方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何 ClassLoader 下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的 Class 对象时，该类就会被 GC 回收。故而 VM Anonymous Class 相比于Java 语言层面的匿名内部类无需通过 ClassClassLoader 进行类加载且更易回收。</li>
</ul>

<p>在 Lambda 表达式实现中，通过 invokedynamic 指令调用引导方法生成调用点，在此过程中，会通过 ASM 动态生成字节码，而后利用 Unsafe 的 defineAnonymousClass 方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应 Lambda 表达式定义逻辑的功能。下面以代码 Demo 类来举例说明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">Demo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Consumer</span> <span class="nf">consumer</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">consumer</span><span class="p">.</span><span class="na">accept</span><span class="p">(</span><span class="s">&#34;lambda&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Demo 类编译后的 class 文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到 main方法的指令实现、invokedynamic 指令调用的引导方法 BootstrapMethods、及静态方法<code>lambda$main$0</code>（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过 Unsafe.defineAnonymousClass 生成如下图二所示的实现 Consumer 接口的匿名类。其中，accept 方法通过调用 Test 类中的静态方法<code>lambda$main$0</code>来实现 Lambda 表达式中定义的逻辑。而后执行语句<code>consumer.accept（&quot;lambda&quot;）</code>其实就是调用下图二所示的匿名类的 accept 方法</p>

<p><img src="https://img-blog.csdnimg.cn/20191224162453358.png" alt="" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="nf">class</span> <span class="n">Test$$Lambda$1</span> <span class="nf">implements</span> <span class="n">Consumer</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="nf">Test$$Lambda$1</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nf">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Demo</span><span class="p">.</span><span class="na">lambda$main$0</span><span class="p">((</span><span class="n">String</span><span class="p">)</span><span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="对象操作">对象操作</h3>

<p>此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">long</span> <span class="nf">objectFieldOffset</span><span class="p">(</span><span class="n">Field</span> <span class="nf">f</span><span class="p">);</span>

<span class="c1">//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Object</span> <span class="nf">getObject</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">);</span>

<span class="c1">//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">putObject</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">x</span><span class="p">);</span>

<span class="c1">//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Object</span> <span class="nf">getObjectVolatile</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">);</span>

<span class="c1">//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">putObjectVolatile</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">x</span><span class="p">);</span>

<span class="c1">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">putOrderedObject</span><span class="p">(</span><span class="n">Object</span> <span class="nf">o</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">offset</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">x</span><span class="p">);</span>

<span class="c1">//绕过构造方法、初始化代码来创建对象
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="n">Object</span> <span class="nf">allocateInstance</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">cls</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">InstantiationException</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="典型应用-4">典型应用</h4>

<ul>
<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>
<li><strong>非常规的实例化方式</strong>：而Unsafe中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>
</ul>

<h3 id="数组相关">数组相关</h3>

<p>这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//返回数组中第一个元素的偏移地址
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">int</span> <span class="nf">arrayBaseOffset</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">arrayClass</span><span class="p">);</span>

<span class="c1">//返回数组中一个元素占用的大小
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">int</span> <span class="nf">arrayIndexScale</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">arrayClass</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="典型应用-5">典型应用</h4>

<p>这两个与数据操作相关的方法，在 java.util.concurrent.atomic 包下的 AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图 AtomicIntegerArray 源码所示，通过Unsafe 的 arrayBaseOffset、arrayIndexScale 分别获取数组首元素的偏移地址 base 及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 getAndAdd 方法即通过 checkedByteOffset 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作</p>

<p><img src="https://img-blog.csdnimg.cn/20191224165039702.png" alt="图一" /></p>

<p><img src="https://img-blog.csdnimg.cn/20191224164434339.png" alt="图二" /></p>

<h3 id="内存屏障">内存屏障</h3>

<p>在 Java 8 中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">loadFence</span><span class="p">();</span>

<span class="c1">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">storeFence</span><span class="p">();</span>

<span class="c1">//内存屏障，禁止load、store操作重排序
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">void</span> <span class="nf">fullFence</span><span class="p">();</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="典型应用-6">典型应用</h4>

<p>在Java 8中引入了一种锁的新机制—— StampedLock ，它可以看成是读写锁的一个改进版本。StampedLock 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 StampedLock 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题，所以当使用 StampedLock 的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性</p>

<p><img src="https://p1.meituan.net/travelcube/839ad79686d06583296f3abf1bec27e3320222.png" alt="img" /></p>

<p>如上图用例所示计算坐标点Point对象，包含点移动方法 move 及计算此点到原点的距离的方法 distanceFromOrigin。在方法 distanceFromOrigin 中，首先，通过 tryOptimisticRead 方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过 StampedLock 的 validate 方法校验锁状态，判断坐标点 (x，y) 从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过 move 方法修改，如果 validate 返回值为 true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前 copy 到线程工作内存中的值是否与主内存的值存在不一致。</p>

<p>下图为 StampedLock.validate 方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过 Unsafe 的 loadFence 方法加入一个load内存屏障，目的是避免上图用例中步骤②和 StampedLock.validate 中锁状态校验运算发生重排序导致锁状态校验不准确的问题</p>

<p><img src="https://img-blog.csdnimg.cn/20191224170014472.png" alt="" /></p>

<h3 id="系统相关">系统相关</h3>

<p>这部分包含两个获取系统相关信息的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">int</span> <span class="nf">addressSize</span><span class="p">();</span>  

<span class="c1">//内存页的大小，此值为2的幂次方。
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">native</span> <span class="kt">int</span> <span class="nf">pageSize</span><span class="p">();</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="典型应用-7">典型应用</h4>

<p>如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="nf">static</span> <span class="kt">int</span> <span class="nf">pageSize</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="p">;</span>

<span class="kd">static</span> <span class="nf">int</span> <span class="n">pageSize</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pageSize</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span><span class="p">)</span>
        <span class="n">pageSize</span> <span class="o">=</span> <span class="n">unsafe</span><span class="p">().</span><span class="na">pageSize</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">pageSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">static</span> <span class="nf">int</span> <span class="n">pageCount</span><span class="p">(</span><span class="kt">long</span> <span class="nf">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pageSize</span><span class="p">()</span> <span class="o">-</span> <span class="n">1L</span><span class="p">)</span> <span class="o">/</span> <span class="n">pageSize</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="结语">结语</h2>

<p>本文对 Java 中的 sun.misc.Unsafe 的用法及应用场景进行了基本介绍，我们可以看到 Unsafe 提供了很多便捷、有趣的API 方法。即便如此，由于 Unsafe 中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">作者</span>
    <span class="item-content">Woo_home</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上一次更新</span>
    <span class="item-content">
        2019-12-23
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/juc/">JUC</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/juc/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-cas/">
            <span class="next-text nav-default">深入浅出 CAS</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="javascripts;" class="iconfont icon-email" title="email"></a>
      <a href="javascripts;" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://github.com/WooGitHub" class="iconfont icon-github" title="github"></a>
      <a href="javascripts;" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/search?type=content&amp;q=" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="javascripts;" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="https://www.bilibili.com/" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://woogithub.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 网站总访问量: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      
    
  </div>

  <span class="copyright-year">
    &copy; 
    2019-08 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Woo_home</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
